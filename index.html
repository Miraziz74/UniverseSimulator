Universe Simulator Code:


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Universe Simulator</title>

<link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="info">
        <h1>Interactive Universe Simulator</h1>
        <p id="sim-description">Select a simulation from the menu</p>
    </div>
    
    <div id="sim-selector">
        <h3>Simulations</h3>
        <select id="simulation">
            <option value="solar">Solar System</option>
            <option value="blackhole">Black Hole</option>
            <option value="supernova">Supernova</option>
            <option value="nebula">Nebula</option>
            <option value="custom">Custom System</option>
        </select>
    </div>
    
    <div id="educational-info">
        <button class="close-btn" id="close-info">Ã—</button>
        <h3>Educational Information</h3>
        <div id="educational-content">
            <div class="info-card">
                <strong>Gravity:</strong> The force that attracts objects with mass. The more massive an object, the stronger its gravitational pull.
            </div>
            <div class="info-card">
                <strong>Orbit:</strong> The curved path of one object around another due to gravity. Orbits are typically elliptical.
            </div>
            <div id="dynamic-info">Select a simulation to learn more.</div>
        </div>
    </div>
    
    <div id="controls">
        <div id="solar-controls" class="sim-controls">
            <label for="planet-selector">Select Planet:</label>
            <select id="planet-selector">
                <option value="sun">Sun</option>
                <option value="mercury">Mercury</option>
                <option value="venus">Venus</option>
                <option value="earth">Earth</option>
                <option value="mars">Mars</option>
                <option value="jupiter">Jupiter</option>
                <option value="saturn">Saturn</option>
                <option value="uranus">Uranus</option>
                <option value="neptune">Neptune</option>
            </select>
            
            <div id="gravity-effects">
                <label>Gravity Multiplier:
                    <div class="slider-container">
                        <span>0.1x</span>
                        <input type="range" id="gravityControl" min="0.1" max="5" step="0.1" value="1">
                        <span class="slider-value">1x</span>
                    </div>
                </label>
                <button id="resetGravity">Reset Gravity</button>
            </div>
            
            <div class="slider-container">
                <button id="toggleOrbits">Toggle Orbits</button>
                <button id="toggleRotation">Toggle Rotation</button>
            </div>
            
            <label>Simulation Speed:
                <div class="slider-container">
                    <span>0.1x</span>
                    <input type="range" id="speedControl" min="0.1" max="10" step="0.1" value="1">
                    <span class="slider-value">1x</span>
                </div>
            </label>
            
            <div id="celestial-interactions">
                <button id="addComet">Add Comet</button>
                <button id="addAsteroid">Add Asteroid Belt</button>
            </div>
            
            <div id="time-controls">
                <button id="timeForward">Fast Forward 100x</button>
                <button id="timeReverse">Reverse Time</button>
            </div>
        </div>
        
        <div id="blackhole-controls" class="sim-controls">
            <label>Black Hole Mass:
                <div class="slider-container">
                    <span>5x</span>
                    <input type="range" id="bhMass" min="5" max="50" value="10">
                    <span class="slider-value">10x</span>
                </div>
            </label>
            
            <label>Stars Count:
                <div class="slider-container">
                    <span>1</span>
                    <input type="range" id="starCount" min="1" max="20" value="5">
                    <span class="slider-value">5</span>
                </div>
            </label>
            
            <div id="celestial-interactions">
                <button id="throwPlanet">Throw a Planet</button>
                <button id="addStarCluster">Add Star Cluster</button>
            </div>
            
            <label>Event Horizon Size:
                <div class="slider-container">
                    <span>1x</span>
                    <input type="range" id="eventHorizon" min="1" max="3" step="0.1" value="1">
                    <span class="slider-value">1x</span>
                </div>
            </label>
            
            <button id="toggleSpaghettification">Toggle Spaghettification</button>
        </div>
        
        <div id="supernova-controls" class="sim-controls">
            <label>Star Mass (Solar Masses):
                <div class="slider-container">
                    <span>8</span>
                    <input type="range" id="starMass" min="8" max="40" value="15">
                    <span class="slider-value">15</span>
                </div>
            </label>
            
            <label>Explosion Energy:
                <div class="slider-container">
                    <span>0.5x</span>
                    <input type="range" id="explosionEnergy" min="0.5" max="3" step="0.1" value="1">
                    <span class="slider-value">1x</span>
                </div>
            </label>
            
            <button id="triggerExplosion">Trigger Supernova</button>
            <button id="addNeutronStar">Form Neutron Star</button>
            <button id="addBlackHoleRemnant">Form Black Hole</button>
            
            <label>Shockwave Effect:
                <div class="slider-container">
                    <span>Low</span>
                    <input type="range" id="shockwave" min="0.5" max="2" step="0.1" value="1">
                    <span class="slider-value">Med</span>
                </div>
            </label>
        </div>
        
        <div id="nebula-controls" class="sim-controls">
            <label>Nebula Size:
                <div class="slider-container">
                    <span>1x</span>
                    <input type="range" id="nebulaSize" min="1" max="20" value="10">
                    <span class="slider-value">10x</span>
                </div>
            </label>
            
            <label>Density:
                <div class="slider-container">
                    <span>Low</span>
                    <input type="range" id="nebulaDensity" min="0.1" max="2" step="0.1" value="1">
                    <span class="slider-value">Med</span>
                </div>
            </label>
            
            <label>Star Formation Rate:
                <div class="slider-container">
                    <span>Low</span>
                    <input type="range" id="starFormation" min="0.1" max="2" step="0.1" value="1">
                    <span class="slider-value">Med</span>
                </div>
            </label>
            
            <button id="addProtostar">Add Protostar</button>
            <button id="simulateCollision">Simulate Cloud Collision</button>
        </div>
        
        <div id="custom-controls" class="sim-controls">
            <button id="addRandomPlanet">Add Random Planet</button>
            <button id="addRandomStar">Add Random Star</button>
            <button id="clearSystem">Clear System</button>
            
            <label>Gravity Constant:
                <div class="slider-container">
                    <span>0.1x</span>
                    <input type="range" id="customGravity" min="0.1" max="5" step="0.1" value="1">
                    <span class="slider-value">1x</span>
                </div>
            </label>
            
            <button id="simulateOrbit">Simulate Orbit</button>
            <button id="simulateCollisionCustom">Simulate Collision</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // Main Three.js elements
        let scene, camera, renderer, controls;
        
        // Simulation objects
        let solarSystem, blackHoleSystem, supernovaSystem, nebulaSystem, customSystem;
        let currentSimulation = null;
        
        // Solar System variables
        let planetObjects = [];
        let orbitCircles = [];
        let showOrbits = true;
        let isRotating = true;
        let speedFactor = 1;
        let timeDirection = 1;
        let gravityFactors = {};
        let comets = [];
        let asteroidBelt = null;
        
        // Black Hole variables
        let starsAroundBlackHole = [];
        let blackHoleMesh, accretionDisk;
        let showSpaghettification = false;
        let planetsNearBlackHole = [];
        
        // Supernova variables
        let starMesh, explosionParticles, neutronStar = null, blackHoleRemnant = null;
        let isExploding = false;
        let explosionTime = 0;
        
        // Nebula variables
        let nebulaParticles, protostars = [];
        
        // Custom system variables
        let customBodies = [];
        
        // Educational content
        const educationalContent = {
            solar: [
                "The Sun contains 99.86% of the mass in our solar system.",
                "Jupiter's gravity is so strong it affects the orbits of other planets.",
                "Saturn's rings are made of billions of ice particles, some as small as dust and others as large as mountains."
            ],
            blackhole: [
                "Black holes have such strong gravity that not even light can escape.",
                "The point of no return around a black hole is called the event horizon.",
                "Spaghettification occurs when tidal forces stretch objects into long, thin shapes near a black hole."
            ],
            supernova: [
                "Supernovae can briefly outshine entire galaxies.",
                "A supernova can reach temperatures of 100 billion degrees Celsius.",
                "Heavy elements like gold and uranium are created in supernova explosions."
            ],
            nebula: [
                "Nebulae are stellar nurseries where new stars are born.",
                "The Orion Nebula is visible to the naked eye as a fuzzy patch in Orion's sword.",
                "Some nebulae glow due to ionization of their gas by nearby hot stars."
            ],
            custom: [
                "You can create your own planetary systems with different physical laws.",
                "Changing gravity affects orbital speeds and system stability.",
                "Celestial collisions can create new planetary bodies or destroy existing ones."
            ]
        };
        
        // Initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 50, 100);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 500;
            controls.minDistance = 5;
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            
            // Add directional light for shadows
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(100, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);
            
            // Create star background
            createStarBackground();
            
            // Initialize all simulations
            initSolarSystem();
            initBlackHole();
            initSupernova();
            initNebula();
            initCustomSystem();
            
            // Set up UI events
            setupUI();
            
            // Start animation loop
            animate();
        }
        
        // Create star background
        function createStarBackground() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                sizeAttenuation: true
            });
            
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x, y, z);
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        // Solar System Simulation
        function initSolarSystem() {
            solarSystem = new THREE.Group();
            solarSystem.visible = false;
            scene.add(solarSystem);
            
            // Planets data
            const planets = [
                { name: "Sun", radius: 6, distance: 0, color: 0xffff00, speed: 0, rotationSpeed: 0.005, mass: 1000 },
                { name: "Mercury", radius: 0.8, distance: 15, color: 0xaaaaaa, speed: 0.04, rotationSpeed: 0.004, mass: 0.055 },
                { name: "Venus", radius: 1.5, distance: 22, color: 0xffaa66, speed: 0.015, rotationSpeed: 0.002, mass: 0.815 },
                { name: "Earth", radius: 1.6, distance: 30, color: 0x3366ff, speed: 0.01, rotationSpeed: 0.01, mass: 1 },
                { name: "Mars", radius: 1.2, distance: 40, color: 0xff3300, speed: 0.008, rotationSpeed: 0.008, mass: 0.107 },
                { name: "Jupiter", radius: 3.5, distance: 60, color: 0xffcc99, speed: 0.002, rotationSpeed: 0.02, mass: 317.8 },
                { name: "Saturn", radius: 3, distance: 80, color: 0xffdd66, speed: 0.0009, rotationSpeed: 0.015, mass: 95.2, hasRing: true },
                { name: "Uranus", radius: 2.5, distance: 95, color: 0x66ccff, speed: 0.0004, rotationSpeed: 0.01, mass: 14.5 },
                { name: "Neptune", radius: 2.4, distance: 110, color: 0x3366ff, speed: 0.0001, rotationSpeed: 0.008, mass: 17.1 }
            ];
            
            // Create planets and orbits
            planets.forEach((planet, index) => {
                // Create planet
                const geometry = new THREE.SphereGeometry(planet.radius, 32, 32);
                const material = new THREE.MeshPhongMaterial({ 
                    color: planet.color,
                    shininess: 30
                });
                const planetMesh = new THREE.Mesh(geometry, material);
                planetMesh.castShadow = true;
                planetMesh.receiveShadow = true;
                
                if (index === 0) {
                    // Sun - at center
                    solarSystem.add(planetMesh);
                    // Add sun glow
                    const sunGlow = new THREE.PointLight(planet.color, 1, 100);
                    sunGlow.castShadow = true;
                    planetMesh.add(sunGlow);
                    
                    // Add corona effect
                    const coronaGeometry = new THREE.SphereGeometry(planet.radius * 1.2, 32, 32);
                    const coronaMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.3,
                        blending: THREE.AdditiveBlending
                    });
                    const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
                    planetMesh.add(corona);
                } else {
                    // Planets - in orbit
                    const orbitGroup = new THREE.Group();
                    orbitGroup.position.x = planet.distance;
                    solarSystem.add(orbitGroup);
                    orbitGroup.add(planetMesh);
                }
                
                // Add rings for Saturn
                if (planet.hasRing) {
                    const ringGeometry = new THREE.RingGeometry(planet.radius * 1.5, planet.radius * 2, 64);
                    const ringMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xddddbb, 
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    planetMesh.add(ring);
                }
                
                // Create orbit path
                const orbitGeometry = new THREE.BufferGeometry();
                const points = [];
                for (let i = 0; i <= 64; i++) {
                    const angle = (i / 64) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        Math.cos(angle) * planet.distance,
                        0,
                        Math.sin(angle) * planet.distance
                    ));
                }
                orbitGeometry.setFromPoints(points);
                const orbitMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x666666, 
                    transparent: true, 
                    opacity: 0.5,
                    linewidth: 2
                });
                const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
                solarSystem.add(orbit);
                orbitCircles.push(orbit);
                
                // Store planet object with additional properties
                planetObjects.push({
                    name: planet.name.toLowerCase(),
                    mesh: planetMesh,
                    orbitGroup: index === 0 ? solarSystem : planetMesh.parent,
                    angle: Math.random() * Math.PI * 2,
                    speed: planet.speed,
                    rotationSpeed: planet.rotationSpeed,
                    distance: planet.distance,
                    mass: planet.mass,
                    originalSpeed: planet.speed
                });
                
                // Initialize gravity factors
                gravityFactors[planet.name.toLowerCase()] = 1;
            });
        }
        
        // Black Hole Simulation
        function initBlackHole() {
            blackHoleSystem = new THREE.Group();
            blackHoleSystem.visible = false;
            scene.add(blackHoleSystem);
            
            // Create black hole
            const bhGeometry = new THREE.SphereGeometry(3, 32, 32);
            const bhMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000,
                wireframe: false
            });
            blackHoleMesh = new THREE.Mesh(bhGeometry, bhMaterial);
            blackHoleSystem.add(blackHoleMesh);
            
            // Create accretion disk
            const diskGeometry = new THREE.RingGeometry(3.5, 15, 64);
            const diskMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5
            });
            accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
            accretionDisk.rotation.x = Math.PI / 2;
            blackHoleSystem.add(accretionDisk);
            
            // Create gravitational lensing effect
            const lensingGeometry = new THREE.SphereGeometry(5, 32, 32);
            const lensingMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vPosition;
                    uniform float time;
                    void main() {
                        float dist = length(vPosition);
                        float intensity = smoothstep(3.0, 5.0, dist);
                        gl_FragColor = vec4(0.0, 0.5, 0.8, 0.3 * intensity * (0.8 + 0.2 * sin(time)));
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
            });
            const lensingSphere = new THREE.Mesh(lensingGeometry, lensingMaterial);
            blackHoleMesh.add(lensingSphere);
            
            // Create initial stars
            createStarsAroundBlackHole(5);
        }
        
        function createStarsAroundBlackHole(count) {
            // Remove old stars
            starsAroundBlackHole.forEach(star => {
                blackHoleSystem.remove(star);
            });
            starsAroundBlackHole = [];
            
            // Create new stars
            for (let i = 0; i < count; i++) {
                const size = 0.5 + Math.random() * 0.5;
                const geometry = new THREE.SphereGeometry(size, 16, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    emissive: 0xffffee,
                    emissiveIntensity: 0.5
                });
                const star = new THREE.Mesh(geometry, material);
                star.castShadow = true;
                
                // Position in a sphere around black hole
                const radius = 15 + Math.random() * 30;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                star.position.x = radius * Math.sin(phi) * Math.cos(theta);
                star.position.y = radius * Math.sin(phi) * Math.sin(theta);
                star.position.z = radius * Math.cos(phi);
                
                // Random velocity
                star.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                
                blackHoleSystem.add(star);
                starsAroundBlackHole.push(star);
            }
        }
        
        function throwPlanetAtBlackHole() {
            const planetSize = 1 + Math.random() * 2;
            const geometry = new THREE.SphereGeometry(planetSize, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: Math.random() * 0xffffff,
                specular: 0x111111,
                shininess: 30
            });
            const planet = new THREE.Mesh(geometry, material);
            planet.castShadow = true;
            
            // Position away from black hole
            planet.position.set(
                50 + Math.random() * 20,
                Math.random() * 10,
                Math.random() * 10
            );
            
            // Velocity towards black hole with some randomness
            planet.userData.velocity = new THREE.Vector3(
                -1 - Math.random(),
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            );
            
            blackHoleSystem.add(planet);
            planetsNearBlackHole.push(planet);
            
            return planet;
        }
        
        // Supernova Simulation
        function initSupernova() {
            supernovaSystem = new THREE.Group();
            supernovaSystem.visible = false;
            scene.add(supernovaSystem);
            
            // Create star (pre-supernova)
            const starGeometry = new THREE.SphereGeometry(2, 32, 32);
            const starMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff8c42,
                emissive: 0xff8c42,
                emissiveIntensity: 0.3
            });
            starMesh = new THREE.Mesh(starGeometry, starMaterial);
            starMesh.castShadow = true;
            supernovaSystem.add(starMesh);
            
            // Create particles for explosion
            const particleCount = 2000;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const velocities = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                // Start all particles at center
                positions[i * 3] = 0;
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = 0;
                
                // Random color (yellow to red)
                colors[i * 3] = 1;
                colors[i * 3 + 1] = 0.3 + Math.random() * 0.7;
                colors[i * 3 + 2] = 0;
                
                sizes[i] = 0.1 + Math.random() * 0.5;
                
                // Random velocity direction
                velocities[i * 3] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
                
                // Normalize and scale velocity
                const length = Math.sqrt(
                    velocities[i * 3] * velocities[i * 3] +
                    velocities[i * 3 + 1] * velocities[i * 3 + 1] +
                    velocities[i * 3 + 2] * velocities[i * 3 + 2]
                );
                
                velocities[i * 3] /= length;
                velocities[i * 3 + 1] /= length;
                velocities[i * 3 + 2] /= length;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            particles.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            
            explosionParticles = new THREE.Points(particles, particleMaterial);
            explosionParticles.visible = false;
            supernovaSystem.add(explosionParticles);
        }
        
        function triggerSupernova() {
            if (isExploding) return;
            
            isExploding = true;
            explosionTime = 0;
            starMesh.visible = false;
            explosionParticles.visible = true;
            
            // Reset particle positions to center
            const positions = explosionParticles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] = 0;
                positions[i + 1] = 0;
                positions[i + 2] = 0;
            }
            explosionParticles.geometry.attributes.position.needsUpdate = true;
        }
        
        function createNeutronStar() {
            if (neutronStar) return;
            
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.7,
                shininess: 100
            });
            neutronStar = new THREE.Mesh(geometry, material);
            neutronStar.position.copy(starMesh.position);
            supernovaSystem.add(neutronStar);
            
            // Add pulsar beams
            const beamGeometry = new THREE.CylinderGeometry(0.1, 0.1, 5, 8);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            
            const beam1 = new THREE.Mesh(beamGeometry, beamMaterial);
            beam1.rotation.x = Math.PI / 2;
            beam1.position.y = 3;
            neutronStar.add(beam1);
            
            const beam2 = new THREE.Mesh(beamGeometry, beamMaterial);
            beam2.rotation.x = Math.PI / 2;
            beam2.position.y = -3;
            neutronStar.add(beam2);
            
            return neutronStar;
        }
        
        function createBlackHoleRemnant() {
            if (blackHoleRemnant) return;
            
            const geometry = new THREE.SphereGeometry(0.3, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
            blackHoleRemnant = new THREE.Mesh(geometry, material);
            blackHoleRemnant.position.copy(starMesh.position);
            supernovaSystem.add(blackHoleRemnant);
            
            // Add small accretion disk
            const diskGeometry = new THREE.RingGeometry(0.5, 1.5, 32);
            const diskMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7
            });
            const disk = new THREE.Mesh(diskGeometry, diskMaterial);
            disk.rotation.x = Math.PI / 2;
            blackHoleRemnant.add(disk);
            
            return blackHoleRemnant;
        }
        
        // Nebula Simulation
        function initNebula() {
            nebulaSystem = new THREE.Group();
            nebulaSystem.visible = false;
            scene.add(nebulaSystem);
            
            // Create particles for nebula
            const particleCount = 5000;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                // Position in a sphere
                const radius = 5 + Math.random() * 15;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
                
                // Random color (purple/blue/pink)
                colors[i * 3] = 0.5 + Math.random() * 0.5; // R
                colors[i * 3 + 1] = Math.random() * 0.3;   // G
                colors[i * 3 + 2] = 0.7 + Math.random() * 0.3; // B
                
                sizes[i] = 0.1 + Math.random() * 0.5;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            nebulaParticles = new THREE.Points(particles, particleMaterial);
            nebulaSystem.add(nebulaParticles);
            
            // Create some stars within the nebula
            for (let i = 0; i < 15; i++) {
                const size = 0.1 + Math.random() * 0.3;
                const geometry = new THREE.SphereGeometry(size, 16, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.3
                });
                const star = new THREE.Mesh(geometry, material);
                
                // Position within nebula
                star.position.x = (Math.random() - 0.5) * 20;
                star.position.y = (Math.random() - 0.5) * 20;
                star.position.z = (Math.random() - 0.5) * 20;
                
                nebulaSystem.add(star);
            }
        }
        
        function addProtostar() {
            const size = 0.5 + Math.random();
            const geometry = new THREE.SphereGeometry(size, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: 0xff6600,
                emissive: 0xff6600,
                emissiveIntensity: 0.5
            });
            const protostar = new THREE.Mesh(geometry, material);
            
            // Position within nebula
            protostar.position.set(
                (Math.random() - 0.5) * 15,
                (Math.random() - 0.5) * 15,
                (Math.random() - 0.5) * 15
            );
            
            // Add accretion disk
            const diskGeometry = new THREE.RingGeometry(size * 1.5, size * 3, 32);
            const diskMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7
            });
            const disk = new THREE.Mesh(diskGeometry, diskMaterial);
            disk.rotation.x = Math.PI / 2;
            protostar.add(disk);
            
            nebulaSystem.add(protostar);
            protostars.push(protostar);
            
            return protostar;
        }
        
        // Custom System Simulation
        function initCustomSystem() {
            customSystem = new THREE.Group();
            customSystem.visible = false;
            scene.add(customSystem);
        }
        
        function addRandomPlanet() {
            const size = 0.5 + Math.random() * 2;
            const geometry = new THREE.SphereGeometry(size, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: Math.random() * 0xffffff,
                specular: 0x111111,
                shininess: 30
            });
            const planet = new THREE.Mesh(geometry, material);
            planet.castShadow = true;
            
            // Random position
            planet.position.set(
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 50
            );
            
            // Random velocity
            planet.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            );
            
            planet.userData.mass = size * 2;
            
            customSystem.add(planet);
            customBodies.push(planet);
            
            return planet;
        }
        
        function addRandomStar() {
            const size = 2 + Math.random() * 3;
            const geometry = new THREE.SphereGeometry(size, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0xffffee,
                emissiveIntensity: 0.5
            });
            const star = new THREE.Mesh(geometry, material);
            star.castShadow = true;
            
            // Random position
            star.position.set(
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 50
            );
            
            star.userData.mass = size * 10;
            
            // Add glow
            const glowGeometry = new THREE.SphereGeometry(size * 1.2, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffee,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            star.add(glow);
            
            customSystem.add(star);
            customBodies.push(star);
            
            return star;
        }
        
        // UI Setup
        function setupUI() {
            // Simulation selector
            document.getElementById('simulation').addEventListener('change', function() {
                switchSimulation(this.value);
            });
            
            // Close educational info button
            document.getElementById('close-info').addEventListener('click', function() {
                document.getElementById('educational-info').style.display = 'none';
            });
            
            // Solar System controls
            document.getElementById('planet-selector').addEventListener('change', function() {
                updateEducationalInfo(this.value);
            });
            
            document.getElementById('toggleOrbits').addEventListener('click', () => {
                showOrbits = !showOrbits;
                orbitCircles.forEach(orbit => {
                    orbit.visible = showOrbits;
                });
            });
            
            document.getElementById('toggleRotation').addEventListener('click', () => {
                isRotating = !isRotating;
            });
            
            document.getElementById('speedControl').addEventListener('input', (e) => {
                speedFactor = parseFloat(e.target.value);
                document.querySelector('#speedControl ~ .slider-value').textContent = speedFactor.toFixed(1) + 'x';
            });
            
            document.getElementById('gravityControl').addEventListener('input', (e) => {
                const planet = document.getElementById('planet-selector').value;
                gravityFactors[planet] = parseFloat(e.target.value);
                document.querySelector('#gravityControl ~ .slider-value').textContent = 
                    gravityFactors[planet].toFixed(1) + 'x';
                
                // Update planet speed based on gravity
                if (planet !== 'sun') {
                    const planetObj = planetObjects.find(p => p.name === planet);
                    if (planetObj) {
                        planetObj.speed = planetObj.originalSpeed * Math.sqrt(gravityFactors[planet]);
                    }
                }
            });
            
            document.getElementById('resetGravity').addEventListener('click', () => {
                const planet = document.getElementById('planet-selector').value;
                gravityFactors[planet] = 1;
                document.getElementById('gravityControl').value = 1;
                document.querySelector('#gravityControl ~ .slider-value').textContent = '1x';
                
                if (planet !== 'sun') {
                    const planetObj = planetObjects.find(p => p.name === planet);
                    if (planetObj) {
                        planetObj.speed = planetObj.originalSpeed;
                    }
                }
            });
            
            document.getElementById('addComet').addEventListener('click', addComet);
            document.getElementById('addAsteroid').addEventListener('click', addAsteroidBelt);
            
            document.getElementById('timeForward').addEventListener('click', () => {
                timeDirection = 100;
            });
            
            document.getElementById('timeReverse').addEventListener('click', () => {
                timeDirection = -1;
            });
            
            // Black Hole controls
            document.getElementById('bhMass').addEventListener('input', (e) => {
                const mass = parseFloat(e.target.value);
                blackHoleMesh.scale.set(mass/10, mass/10, mass/10);
                accretionDisk.scale.set(mass/10, mass/10, mass/10);
                document.querySelector('#bhMass ~ .slider-value').textContent = mass + 'x';
            });
            
            document.getElementById('starCount').addEventListener('input', (e) => {
                const count = parseInt(e.target.value);
                createStarsAroundBlackHole(count);
                document.querySelector('#starCount ~ .slider-value').textContent = count;
            });
            
            document.getElementById('eventHorizon').addEventListener('input', (e) => {
                const size = parseFloat(e.target.value);
                // This would affect the visual representation of the event horizon
                document.querySelector('#eventHorizon ~ .slider-value').textContent = size.toFixed(1) + 'x';
            });
            
            document.getElementById('toggleSpaghettification').addEventListener('click', () => {
                showSpaghettification = !showSpaghettification;
            });
            
            document.getElementById('throwPlanet').addEventListener('click', throwPlanetAtBlackHole);
            document.getElementById('addStarCluster').addEventListener('click', () => {
                createStarsAroundBlackHole(10);
            });
            
            // Supernova controls
            document.getElementById('starMass').addEventListener('input', (e) => {
                const mass = parseFloat(e.target.value);
                starMesh.scale.set(mass/15, mass/15, mass/15);
                document.querySelector('#starMass ~ .slider-value').textContent = mass;
            });
            
            document.getElementById('explosionEnergy').addEventListener('input', (e) => {
                const energy = parseFloat(e.target.value);
                document.querySelector('#explosionEnergy ~ .slider-value').textContent = energy.toFixed(1) + 'x';
            });
            
            document.getElementById('shockwave').addEventListener('input', (e) => {
                const wave = parseFloat(e.target.value);
                document.querySelector('#shockwave ~ .slider-value').textContent = 
                    wave < 1 ? 'Low' : wave > 1.5 ? 'High' : 'Med';
            });
            
            document.getElementById('triggerExplosion').addEventListener('click', triggerSupernova);
            document.getElementById('addNeutronStar').addEventListener('click', createNeutronStar);
            document.getElementById('addBlackHoleRemnant').addEventListener('click', createBlackHoleRemnant);
            
            // Nebula controls
            document.getElementById('nebulaSize').addEventListener('input', (e) => {
                const size = parseFloat(e.target.value);
                nebulaSystem.scale.set(size/10, size/10, size/10);
                document.querySelector('#nebulaSize ~ .slider-value').textContent = size + 'x';
            });
            
            document.getElementById('nebulaDensity').addEventListener('input', (e) => {
                const density = parseFloat(e.target.value);
                nebulaParticles.material.opacity = 0.3 * density;
                document.querySelector('#nebulaDensity ~ .slider-value').textContent = 
                    density < 0.7 ? 'Low' : density > 1.3 ? 'High' : 'Med';
            });
            
            document.getElementById('starFormation').addEventListener('input', (e) => {
                const rate = parseFloat(e.target.value);
                document.querySelector('#starFormation ~ .slider-value').textContent = 
                    rate < 0.7 ? 'Low' : rate > 1.3 ? 'High' : 'Med';
            });
            
            document.getElementById('addProtostar').addEventListener('click', addProtostar);
            document.getElementById('simulateCollision').addEventListener('click', () => {
                // Simulate nebula collision by moving particles
                const positions = nebulaParticles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] *= 1.1;
                    positions[i + 1] *= 1.1;
                    positions[i + 2] *= 1.1;
                }
                nebulaParticles.geometry.attributes.position.needsUpdate = true;
            });
            
            // Custom system controls
            document.getElementById('addRandomPlanet').addEventListener('click', addRandomPlanet);
            document.getElementById('addRandomStar').addEventListener('click', addRandomStar);
            document.getElementById('clearSystem').addEventListener('click', () => {
                customBodies.forEach(body => customSystem.remove(body));
                customBodies = [];
            });
            
            document.getElementById('customGravity').addEventListener('input', (e) => {
                const gravity = parseFloat(e.target.value);
                document.querySelector('#customGravity ~ .slider-value').textContent = gravity.toFixed(1) + 'x';
            });
            
            document.getElementById('simulateOrbit').addEventListener('click', () => {
                if (customBodies.length < 2) return;
                
                // Simple orbit simulation - make the lighter body orbit the heavier one
                customBodies.sort((a, b) => b.userData.mass - a.userData.mass);
                const centralBody = customBodies[0];
                const orbitingBody = customBodies[1];
                
                // Position orbiting body at a distance
                const distance = 20;
                orbitingBody.position.set(
                    centralBody.position.x + distance,
                    centralBody.position.y,
                    centralBody.position.z
                );
                
                // Set velocity for orbit
                const gravity = parseFloat(document.getElementById('customGravity').value);
                const orbitalSpeed = Math.sqrt(gravity * centralBody.userData.mass / distance) * 0.1;
                orbitingBody.userData.velocity = new THREE.Vector3(
                    0,
                    orbitalSpeed,
                    0
                );
            });
            
            document.getElementById('simulateCollisionCustom').addEventListener('click', () => {
                if (customBodies.length < 2) return;
                
                // Position two bodies to collide
                const body1 = customBodies[0];
                const body2 = customBodies[1];
                
                body1.position.set(-10, 0, 0);
                body2.position.set(10, 0, 0);
                
                body1.userData.velocity = new THREE.Vector3(1, 0, 0);
                body2.userData.velocity = new THREE.Vector3(-1, 0, 0);
            });
            
            // Start with solar system
            switchSimulation('solar');
        }
        
        function addComet() {
            const size = 0.3 + Math.random() * 0.5;
            const geometry = new THREE.SphereGeometry(size, 16, 16);
            const material = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
            const comet = new THREE.Mesh(geometry, material);
            
            // Position far from sun with high eccentricity
            const distance = 120 + Math.random() * 50;
            const angle = Math.random() * Math.PI * 2;
            
            comet.position.set(
                Math.cos(angle) * distance,
                (Math.random() - 0.5) * 20,
                Math.sin(angle) * distance
            );
            
            // Velocity towards sun with some tangential component
            const sunPos = planetObjects[0].orbitGroup.position;
            const direction = new THREE.Vector3().subVectors(sunPos, comet.position).normalize();
            const tangent = new THREE.Vector3(-direction.z, 0, direction.x).normalize();
            
            const tangentAmount = 0.3 + Math.random() * 0.5;
            comet.userData.velocity = new THREE.Vector3()
                .copy(direction)
                .multiplyScalar(0.5)
                .add(tangent.multiplyScalar(tangentAmount));
            
            comet.userData.isComet = true;
            solarSystem.add(comet);
            comets.push(comet);
            
            return comet;
        }
        
        function addAsteroidBelt() {
            if (asteroidBelt) {
                solarSystem.remove(asteroidBelt);
            }
            
            const asteroidCount = 100;
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.2,
                sizeAttenuation: true
            });
            
            const positions = new Float32Array(asteroidCount * 3);
            for (let i = 0; i < asteroidCount; i++) {
                // Position in a belt between Mars and Jupiter
                const angle = Math.random() * Math.PI * 2;
                const distance = 45 + Math.random() * 15;
                const height = (Math.random() - 0.5) * 5;
                
                positions[i * 3] = Math.cos(angle) * distance;
                positions[i * 3 + 1] = height;
                positions[i * 3 + 2] = Math.sin(angle) * distance;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            asteroidBelt = new THREE.Points(geometry, material);
            solarSystem.add(asteroidBelt);
            
            return asteroidBelt;
        }
        
        function updateEducationalInfo(planet) {
            const infoMap = {
                sun: "The Sun is a G-type main-sequence star that contains 99.86% of the mass in the Solar System.",
                mercury: "Mercury is the smallest and innermost planet with extreme temperature variations.",
                venus: "Venus is the hottest planet with a thick, toxic atmosphere of carbon dioxide.",
                earth: "Earth is the only known planet with liquid water on the surface and life.",
                mars: "Mars has the largest volcano and canyon in the solar system.",
                jupiter: "Jupiter is the largest planet with a Great Red Spot storm larger than Earth.",
                saturn: "Saturn's rings are made of ice and rock particles, some as small as grains of sand.",
                uranus: "Uranus rotates on its side, likely due to a collision with an Earth-sized object.",
                neptune: "Neptune has the strongest winds in the solar system, reaching 2,100 km/h."
            };
            
            document.getElementById('dynamic-info').innerHTML = `
                <div class="info-card">
                    <strong>${planet.charAt(0).toUpperCase() + planet.slice(1)}:</strong> ${infoMap[planet]}
                </div>
                <div class="info-card">
                    <strong>Gravity Experiment:</strong> Adjust the gravity multiplier to see how it affects the planet's orbit.
                    Higher gravity makes orbits faster and can make planets spiral inward if too strong.
                </div>
            `;
        }
        
        // Switch between simulations
        function switchSimulation(simType) {
            // Hide all simulations
            if (currentSimulation) currentSimulation.visible = false;
            
            // Hide all control panels
            document.querySelectorAll('.sim-controls').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Reset time direction
            timeDirection = 1;
            
            // Show selected simulation and controls
            switch(simType) {
                case 'solar':
                    solarSystem.visible = true;
                    currentSimulation = solarSystem;
                    document.getElementById('solar-controls').classList.add('active');
                    document.getElementById('sim-description').textContent = "Solar System: Observe planetary orbits and experiment with gravity";
                    camera.position.set(0, 50, 100);
                    updateEducationalInfo('sun');
                    showEducationalContent('solar');
                    break;
                    
                case 'blackhole':
                    blackHoleSystem.visible = true;
                    currentSimulation = blackHoleSystem;
                    document.getElementById('blackhole-controls').classList.add('active');
                    document.getElementById('sim-description').textContent = "Black Hole: Watch stars orbit and experiment with extreme gravity";
                    camera.position.set(0, 30, 50);
                    showEducationalContent('blackhole');
                    break;
                    
                case 'supernova':
                    supernovaSystem.visible = true;
                    currentSimulation = supernovaSystem;
                    document.getElementById('supernova-controls').classList.add('active');
                    document.getElementById('sim-description').textContent = "Supernova: Trigger and study massive stellar explosions";
                    camera.position.set(0, 0, 30);
                    showEducationalContent('supernova');
                    break;
                    
                case 'nebula':
                    nebulaSystem.visible = true;
                    currentSimulation = nebulaSystem;
                    document.getElementById('nebula-controls').classList.add('active');
                    document.getElementById('sim-description').textContent = "Nebula: Explore star-forming regions and stellar nurseries";
                    camera.position.set(0, 0, 30);
                    showEducationalContent('nebula');
                    break;
                    
                case 'custom':
                    customSystem.visible = true;
                    currentSimulation = customSystem;
                    document.getElementById('custom-controls').classList.add('active');
                    document.getElementById('sim-description').textContent = "Custom System: Create your own celestial systems with custom physics";
                    camera.position.set(0, 50, 100);
                    showEducationalContent('custom');
                    break;
            }
            
            controls.reset();
            document.getElementById('educational-info').style.display = 'block';
        }
        
        function showEducationalContent(simType) {
            const content = educationalContent[simType];
            let html = '';
            
            content.forEach(text => {
                html += `<div class="info-card">${text}</div>`;
            });
            
            document.getElementById('dynamic-info').innerHTML = html;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update current simulation
            if (currentSimulation === solarSystem) {
                if (isRotating) {
                    // Update planet positions and rotations
                    planetObjects.forEach(planet => {
                        if (planet.speed > 0) {
                            planet.angle += planet.speed * speedFactor * timeDirection;
                            planet.orbitGroup.position.x = Math.cos(planet.angle) * planet.distance;
                            planet.orbitGroup.position.z = Math.sin(planet.angle) * planet.distance;
                        }
                        planet.mesh.rotation.y += planet.rotationSpeed * speedFactor * timeDirection;
                    });
                }
                
                // Update comets
                comets.forEach((comet, index) => {
                    const sunPos = planetObjects[0].orbitGroup.position;
                    const direction = new THREE.Vector3().subVectors(sunPos, comet.position).normalize();
                    const distanceSq = comet.position.distanceToSquared(sunPos);
                    
                    // Apply gravity (stronger when closer to sun)
                    const gravityStrength = 0.1 / distanceSq;
                    comet.userData.velocity.add(direction.multiplyScalar(gravityStrength * speedFactor * timeDirection));
                    
                    // Update position
                    comet.position.add(comet.userData.velocity.clone().multiplyScalar(speedFactor * timeDirection));
                    
                    // Remove comets that get too close to sun or too far away
                    if (distanceSq < 25 || distanceSq > 40000) {
                        solarSystem.remove(comet);
                        comets.splice(index, 1);
                    }
                });
            }
            else if (currentSimulation === blackHoleSystem) {
                // Rotate black hole and disk
                blackHoleMesh.rotation.y += 0.01;
                accretionDisk.rotation.y += 0.02;
                
                // Make stars orbit and some fall into black hole
                starsAroundBlackHole.forEach((star, index) => {
                    const direction = new THREE.Vector3().subVectors(blackHoleMesh.position, star.position).normalize();
                    const distanceSq = star.position.distanceToSquared(blackHoleMesh.position);
                    
                    // Apply gravity
                    const gravityStrength = 0.5 / distanceSq;
                    star.userData.velocity.add(direction.multiplyScalar(gravityStrength));
                    
                    // Update position
                    star.position.add(star.userData.velocity);
                    
                    // Spaghettification effect
                    if (showSpaghettification && distanceSq < 50) {
                        const stretchFactor = 1 + (50 - distanceSq) / 10;
                        star.scale.y = stretchFactor;
                        star.scale.x = star.scale.z = 1 / Math.sqrt(stretchFactor);
                    } else {
                        star.scale.set(1, 1, 1);
                    }
                    
                    // Remove stars that get too close
                    if (distanceSq < 9) {
                        blackHoleSystem.remove(star);
                        starsAroundBlackHole.splice(index, 1);
                    }
                });
                
                // Update planets near black hole
                planetsNearBlackHole.forEach((planet, index) => {
                    const direction = new THREE.Vector3().subVectors(blackHoleMesh.position, planet.position).normalize();
                    const distanceSq = planet.position.distanceToSquared(blackHoleMesh.position);
                    
                    // Apply gravity
                    const gravityStrength = 0.5 / distanceSq;
                    planet.userData.velocity.add(direction.multiplyScalar(gravityStrength));
                    
                    // Update position
                    planet.position.add(planet.userData.velocity);
                    
                    // Spaghettification effect
                    if (showSpaghettification && distanceSq < 50) {
                        const stretchFactor = 1 + (50 - distanceSq) / 10;
                        planet.scale.y = stretchFactor;
                        planet.scale.x = planet.scale.z = 1 / Math.sqrt(stretchFactor);
                    } else {
                        planet.scale.set(1, 1, 1);
                    }
                    
                    // Remove planets that get too close
                    if (distanceSq < 9) {
                        blackHoleSystem.remove(planet);
                        planetsNearBlackHole.splice(index, 1);
                    }
                });
            }
            else if (currentSimulation === supernovaSystem) {
                if (isExploding) {
                    explosionTime += 0.01;
                    
                    // Expand particles
                    const positions = explosionParticles.geometry.attributes.position.array;
                    const velocities = explosionParticles.geometry.attributes.velocity.array;
                    const energyFactor = parseFloat(document.getElementById('explosionEnergy').value);
                    const shockwaveFactor = parseFloat(document.getElementById('shockwave').value);
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        // Move particles according to their velocity
                        positions[i] += velocities[i] * energyFactor * shockwaveFactor * 0.2;
                        positions[i + 1] += velocities[i + 1] * energyFactor * shockwaveFactor * 0.2;
                        positions[i + 2] += velocities[i + 2] * energyFactor * shockwaveFactor * 0.2;
                    }
                    explosionParticles.geometry.attributes.position.needsUpdate = true;
                    
                    // Fade out
                    if (explosionTime > 3) {
                        explosionParticles.material.opacity *= 0.98;
                    }
                    
                    if (explosionTime > 5) {
                        isExploding = false;
                        explosionTime = 0;
                        starMesh.visible = true;
                        explosionParticles.visible = false;
                        explosionParticles.material.opacity = 0.9;
                        
                        // Remove remnants if they exist
                        if (neutronStar) {
                            supernovaSystem.remove(neutronStar);
                            neutronStar = null;
                        }
                        if (blackHoleRemnant) {
                            supernovaSystem.remove(blackHoleRemnant);
                            blackHoleRemnant = null;
                        }
                    }
                }
                
                // Pulsar rotation
                if (neutronStar) {
                    neutronStar.rotation.y += 0.1;
                }
            }
            else if (currentSimulation === nebulaSystem) {
                // Slowly rotate nebula
                nebulaParticles.rotation.y += 0.001;
                
                // Random motion for protostars
                protostars.forEach(protostar => {
                    protostar.rotation.y += 0.01;
                    protostar.position.x += (Math.random() - 0.5) * 0.02;
                    protostar.position.y += (Math.random() - 0.5) * 0.02;
                    protostar.position.z += (Math.random() - 0.5) * 0.02;
                });
            }
            else if (currentSimulation === customSystem) {
                // Simulate gravity between bodies
                const gravityConstant = parseFloat(document.getElementById('customGravity').value) * 0.1;
                
                for (let i = 0; i < customBodies.length; i++) {
                    const bodyA = customBodies[i];
                    
                    for (let j = i + 1; j < customBodies.length; j++) {
                        const bodyB = customBodies[j];
                        const direction = new THREE.Vector3().subVectors(bodyB.position, bodyA.position);
                        const distanceSq = direction.lengthSq();
                        const distance = Math.sqrt(distanceSq);
                        direction.normalize();
                        
                        // Calculate gravitational force
                        const force = gravityConstant * bodyA.userData.mass * bodyB.userData.mass / distanceSq;
                        
                        // Apply forces
                        if (bodyA.userData.velocity) {
                            bodyA.userData.velocity.add(direction.clone().multiplyScalar(force / bodyA.userData.mass * 0.01));
                        }
                        if (bodyB.userData.velocity) {
                            bodyB.userData.velocity.add(direction.clone().multiplyScalar(-force / bodyB.userData.mass * 0.01));
                        }
                    }
                    
                    // Update position if body has velocity
                    if (bodyA.userData.velocity) {
                        bodyA.position.add(bodyA.userData.velocity);
                    }
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start the application
        init();
    </script>
</body>
</html>

 

